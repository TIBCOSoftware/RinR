---
title: "RinR"
author: "Stephen Kaluzny"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{RinR}
---

<!--
Copyright 2021. TIBCO Software Inc.
This file is subject to the license terms contained
in the license file that is distributed with this file.
-->

The RinR package provides functions for running code in one R interpreter
from within another R interpreter.
The R interpreters can be different versions of open-source R
or the TERR (TIBCO Enterprise Runtime for R) interpreter.
The `RCompare` function in the package can run an expression in two different
R interpreters and compare the results.
The `RGraph` function can be used to generate graphics in TERR
by calling graphics functions in an open-source R interpreter.

The RinR package is included with TERR 2.0 (and later versions).
The package can be downloaded from the TERR community site for
use with R.
The package should also soon be available on CRAN.

Along with the `RinR` package, this vignette uses the `MASS` and `lattice` packages that are included with open-source R.
The `ggplot2` and `devtools` packages from CRAN are also used.

## Evaluators
The main functions of the RinR package are the evaluators.
These functions execute a given expression in the specified R interpreter.
The specified R interpreter is started with these command
line arguments: "`--quiet --vanilla --no-echo`".
Note that this means that neither the  system `Rprofile.site` nor
the user's `.Rprofile` (for R) or `.TERRprofile` for TERR will be run.

The return value from an evaluator is a list of length 1
containing the value of the evaluated expression.
The name of the list component is the `version$verstion.string`
from the R interpreter used in the evaluation.
The `REvaluate` function returns just the value of the
evaluated expression in the specified R interpreter.

You can have many evaluator functions, one for each R interpreter
that you want to evaluate an expression in.

The `makeEvaluator` function is used to create an evaluator
for a particular R interpreter.

```{r makeREvaluator}
library(RinR)
R4.1.2 <- makeREvaluator("R", RHome="/home/R/R-4.1.2")
R4.1.2(version$version.string)
R4.0.5 <- makeREvaluator("R", RHome="/home/R/R-4.0.5")
R4.0.5(version$version.string)
```
The RinR package comes with several default evaluators.

* `LocalEvaluator` - the current interpreter (R or TERR)
* `REvaluator` - an R interpreter
* `TERREvaluator` - a TERR interpreter

These evaluators are created with the `configureREvaluator` function
when the RinR package is loaded.

## Finding the R Interpreters

The RinR package must be able to find the various R interpreters that you
want the package to evaluate code in.

RinR tries to find the location of the R interpreter based on the values of

* `options("RinR_R_FULL_PATH")`,
* `options("RinR_TERR_FULL_PATH")`
* values in the Windows registry,
* commonly-used locations in the file system,
* directories in `Sys.getenv("PATH")`.

If you regularly use the RinR package it is recommended what you set the
options `RinR_R_FULL_PATH` and/or `RinR_TERR_FULL_PATH` in your
startup file.
The value of the option should be the full path to the R binary e.g.:
```{r FULL_PATH, eval=FALSE}
options(RinR_R_FULL_PATH="/usr/local/bin/R-4.0.5")
options(RinR_TERR_FULL_PATH="/usr/local/bin/TERR-6.0")
```
This will ensure that you always get the specified R interpreter when using
the default `REvaluator` and `TERREvaluator` functions.

If a default evaluators could not be configured when the
package is loaded,
the evaluator will look in the system path (`Sys.getenv("PATH")`)
for the appropriate interpreter when the evaluator function is called.

The `pushPath` function can add the path to an R interpreter to the system path e.g.

```{r pushPath, eval=FALSE}
pushPATH("/home/R/R-4.0.5/bin")
```

The `popPATH` function can  be used to remove the first value from the
system path (to undo a `pushPATH` call).

The `pushPATH` and `popPATH` function only modify the system path
for the current R / TERR session.

## Using `REvaluate`

`REvaluate` directly returns the value from the expression.
```{r REvaluate01}
REvaluate(version$version.string, LocalEvaluator)
REvaluate(version$language, REvaluator)
REvaluate(version$language, TERREvaluator)
REvaluate(version$version.string, LocalEvaluator)
```

The `data` argument to `REvaluate` is used to pass data to the R engine that
will be called.
The argument can either be a character vector or a list with named components.

```{r REvaluate02}
REvaluate(log2(p), TERREvaluator, data=list(p=16:32))
p <- 60:67
REvaluate(log2(p), REvaluator, data="p")
```

To load a package for use by the `REvaluate` expression you can
either explicilty call `library` in the expression
or use the `packages` argument to `REvaluate`.
```{r REvaluate03}
rlmFit <- REvaluate({library(MASS); rlm(body_mass_g ~ bill_depth_mm + sex,
    peng)}, data = list(peng = palmerpenguins::penguins))
```

## `multiREvaluator` and `RCompare`

The `multiREvaluator` function evaluates an expression in one
or more R interpreters.
The specific R interpreters used are specified as a list of `REvaluator`
objects in the `REvaluators` argument.
The default is `DefaultREvaluators()` which contains an evaluator
for R and for TERR.

The `RCompare` function uses the multiREvaluator to evaluate
an expression in multiple R interpreters and return the results in a list.
The names of the list are the names of the evaluators used.
The return value also includes the results of running
`all.equal` comparing the first value in the list with each of the
other values.
The return object is of class `"sideBySide"` and there is a `print`
method for the class to display the results.

```{r RCompare01}
RCompare(log2(xTest), data = list(xTest=4:16))
```

Here is an example where TERR and open-source R differ.
The `seq.Date` function in TERR uses the last day of each month if the `from` argument is
a last day, even if the subsequent months have less days.
Open-source R moves into the next month if the number of days is less than the `from` argument.
```{r RCompare02}
#TERR4.2 <- makeREvaluator("TERR", RHome="/home/TERR/TERR-4.2.0")
#R3.3.1 <- makeREvaluator("R", RHome="C:/Program Files/R/R-3.3.1")
RCompare(seq(as.Date("2000-01-31"), by = "months", length = 12))
```

There is a `sideBySide` function that converts any list into
an object of class `"sideBySide"`.
This is a useful way to compare multiple results, even if
they were not computed in different R interpreters.
The `.PRINTFUN` argument can be used to specify a particular
print method for the display (see the example below).

```{r sideBySide}
sideBySide(list(NaiveFactorial=sapply(1:10, function(i) prod(1:i)),
    ViaGamma=gamma((1:10)+1)))
# may need options(width=124)
sideBySide(list(Default=terms(y ~ 1), NoIntercept=terms(y ~ -1)),
    PRINTFUN="str")
```

## Installing Packages with RinR

To use packages installed in Open Source R within TERR you need to
let TERR know where to find the packages.
The `.libPaths` function sets the search path for finding packages.
You can use `REvaluate` to find the package search path use by Open Source
R and then set that for TERR:

The current package search path:
```{r .libPaths, eval=FALSE}
.libPaths()
## [1] "/home/TERR/TERR-4.2.0/site-library" "/home/TERR/TERR-4.2.0/library"
```

Append Open Source R's package search path to TERR's:
```{r adding to .libPaths, eval=FALSE}
.libPaths(c(.libPaths(), REvaluate(.libPaths())))
.libPaths()
## [1] "/home/TERR/TERR-4.2.0/site-library" "/home/TERR/TERR-4.2.0/library"
## [3] "/home/R/R-3.3.1/lib/R/site-library" "/home/R/R-3.3.1/lib/R/library"
```

You can install packages from CRAN for use in TERR with the RinR package.
This is especially useful under Linux since `install.packages` cannot
be used in TERR under Linux with packages that contain C or Fortran
source code
(`install.packages` on Windows installs binary packages from CRAN but
only source packages are available on CRAN for Linux).

In the example below we install the `minimax` package in a library whose
name gets created in TERR.
We need to pass the library name as `data` in the `REvaluate` call so that
R knows where to install the package.
We also need explicitly set the `repos` value since the default interactive
setting cannot occur in the R called `REvaluate`.

```{r install.packages example}
tlib <- tempfile("lib")
dir.create(tlib)
re <- REvaluate(
    install.packages("minimax", lib=tlib, repos="https://cloud.r-project.org"),
    data=list(tlib=tlib)
)
library(minimax, lib=tlib)
p <- pminimax(0:10/10, 1:5, 2)
p
q <- qminimax(p, 1:5, 2)
q
```

You can also install R packages from Github using RinR and the `devtools`
package.
In example below we install the `medley` package for blending regression models
(see: https://github.com/mewo2/medley).
The `install_github` function does not have a `lib` argument
like `install.packages`
so we use `withr::with_libpaths` function to set a library location.
```{r devtools example, eval=F}
tlib <- tempfile("lib")
dir.create(tlib)
re <- REvaluate(
    withr::with_libpaths(tlib, install_github('mewo2/medley')),
    data=list(tlib=tlib),
    packages="devtools"
)
library(medley, lib=tlib)
rmse(true=c(1:5), c(.5, 1.5, 3, 4.5, 5.5))
```

## RGraph

The `RGraph` function generates graphics by using an REvaluator to
send an expression that creates a graph to R, evaluate it and send the 
resulting graph back to the calling interpreter.
This provides a method of generating graphics from a TERR interpreter which does
not yet support graphics.

The `graphicsDevice` argument specifies the R function that produces the
desired graphics file format: `png`, `pdf`, `jpeg` and `win.metafile`
only on Windows).  The default is `png`.

The resulting graphic is always written to a file.
The `file` argument can be used to specify the exact filename,
otherwise a temporay file, with appropriate file extension,
(based on the `graphicsDevice` argument),
is used.

If `display=TRUE`, the graphic is displayed using the function
given in the `viewer` argument.
If `returnFilename` is `FALSE`, the `RGraph` function returns the 
graphic as a raw vector.
If `returnFilename` is `TRUE`, the name of the file containg the
graphic is returned and the file is not removed when the
function is done.

```{r RGraph01}
### basic plot ###
RGraph(hist(pg$body_mass_g), data=list(pg=palmerpenguins::penguins),
    display = TRUE)
```

```{r RGraph02, echo=c(1:2, 5)}
### image in jpeg format ###
grFile <- RGraph(image(m13),
    data=list(m13=matrix(sample(1:13, 144, TRUE), ncol=13)),
    graphicsDevice="jpeg", deviceArgs=list(pointsize=20),
    returnFile=TRUE)
copied <- file.copy(grFile, basename(grFile))
knitr::include_graphics(basename(grFile))
unlink(grFile) # clean up when done looking at the file
```

```{r RGraph03, echo=1:3}
### use lattice package ###
lat <- RGraph(print(xyplot(mpg ~ wt | cyl, data=mt)),
    data=list(mt=mtcars), packages="lattice")
writeBin(lat, "lattice.png")
knitr::include_graphics("lattice.png")
```

```{r RGraph04, echo=1:3}
### use ggplot2 package ###
gg <- RGraph({p <- ggplot(data=airquality, aes(x=Temp, y=Ozone, color=Month));
    print(p + geom_point())}, data=list(airquality=airquality),
    packages="ggplot2")
writeBin(gg, "ggplot.png")
knitr::include_graphics("ggplot.png")
```

## Using `RGraph` with Spotfire Data Functions

The `RGraph` function can be used to create R graphics in
TERR data function.
The resulting graphics is stored as a raw binary object
and can be passed back to Spotfire to be displayed as
a static image.

The typical use would be to call `RGraph` from a TERR
data function with `display=FALSE` and `returnFilename=FALSE`.
The return value from `RGraph` is the raw binary image.
This return value is declared a return value from the
data function.
The data function should display the value as a binary value
in the Spotfire file.

To use `RGraph` from a TERR data function, the R interpreter must
be configured in an REvaluator on the machine running TERR.
